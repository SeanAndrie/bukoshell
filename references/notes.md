# Minishell Notes

**Conceptual Architecture:**

```
Input -> [Lexer] -> [Tokenizer] -> [Parser] -> [Expander] -> [Executor] -> Output
```

## 1. The Main Loop 
This is the outermost layer of your shell. Its job is simple but crucial:

1. Print a prompt (using `readline`).
2. Read a line of input from the user.
3. Pass that input to the parsing and execution pipeline.
4. Repeat until told to exit.

**Key Characteristics:**
- Handles `Ctrl-D` (EOF) to exit.
- Often manages the lifetime of the shell's internal state (like the environment variable list).

### 1.1. `readline` in MacOS
Apple's built-in `readline` library in macOS is not the full GNU version that your code expects. It's often a symbolic link to the `libedit` library, which has a different API. When you compile with `-lreadline`, it links against this incomplete/broken Apple version, leading to compilation errors or strange runtime behaviour (like no arrow keys or history).

### Solution:  Install GNU Readline via Homebrew
This is the best solution because it gives you the full, correct version of the library.

**Step 1: Install Homebrew**
Paste this in your terminal:

```
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
```
Follow the on-screen instructions. At the end, it will tell you to add Homebrew to your PATH. **You must do this**.

**Step 2: Install GNU Readline**

```
brew install readline
```

**Step 3: Update your Makefile**
You need to tell your compiler to look for the Homebrew version of `readline` instead of the system one. Homebrew installs it in a special directory, usually `/opt/homebrew/opt/readline` for Apple Silicon Macs (M1/M2) or `/user/local/opt/readline` for Intel Macs.

```Makefile
CFLAGS = -Wall -Wextra -Werror -I/usr/local/opt/readline/include
LDFLAGS = -L/usr/local/opt/readline/lib

$(NAME): $(OBJS)
    $(CC) $(CFLAGS) $(OBJS) $(LDFLAGS) -o $(NAME) -lreadline -lncurses
```

The `-I` flag adds the correct directory to the header search path, so #`include <readline/readline.h>` finds the Homebrew version. The `-L` flag adds the correct directory to the library search path, so `-lreadline` links against the full GNU library.

# 2. The Parser
The parser's job is to take the raw string of input and convert it to a structured data format that the executor can understand. This is often the most challenging part. It's typically broken down into several stages:

> **TLDR**: the *tokenizer*'s role is to <u>**extract**</u> all the meaningful chunks from reading a stream of characters, while the *lexer* is meant to <u>**categorize**</u> these tokens. So they are not necessarily separate steps in the process of parsing, but rather (and in practice), they are fused into a single, cohesive scanning step. 

## 2.1. Lexer (Lexical Analysis)
- **Goal:** Split the input string into a sequence of meaningful "tokens".
- **What it does:** It scans the string character by character, grouping them into tokens. It must understand the grammar of the shell.
- **Crucial Challenege:** Handling quotes (`'` and `''`). Everything inside matching quotes must be treated as a single token, ignoring the special characters (like `|` or `>`) inside them.
- Example:
    - Input: `echo "hello world" > file.txt | cat`
    - Tokens: `echo`, `"hello world"`, `>`, `file.txt`, `|`, `cat`

## 2.2. Tokenizer (Syntax Analysis)
- **Goal:** Classify each token generated by the lexer.
- **What it does:** It assigns a type to each token. This is essential for the next step.
- **Common Token Types:**
    - `TOKEN_WORD` (e.g. `echo`, `ls`, `-l`, `"hello world`")
    - `TOKEN_PIPE` (`|`)
    - `TOKEN_REDIRECT_IN` & `TOKEN_REDIRECT_OUT` (`<` & `>`)
    - `TOKEN_REDIRECT_APPEND` (`>>`)
    - `TOKEN_HEREDOC` (`<<`)
    - `TOKEN_EOF` (end of input)

## 2.3 Parser (Building the Syntax Tree)
- **Goal:** Take the list of classified tokens and build an Abstract Syntax Tree (AST) or a command table.
- **What it does:** It checks if the sequence of tokens makes sense (syntax validation) and then structures them into commands, their arguments, and their redirections. The most common structure for a shell is a linked list of simple commands, connected by pipes.
- **Output Data Structure**: Each node in the list represents a single commad in a pipeline.
